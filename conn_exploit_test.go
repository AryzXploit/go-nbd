// SPDX-License-Identifier: Apache-2.0

package nbd

import (
	"encoding/binary"
	"fmt"
	"net"
	"testing"

	"github.com/digitalocean/go-nbd/internal/nbdproto"
)

// TestReadStructuredReplyOffsetUnderflow demonstrates the panic that occurs when
// a server returns a structured reply whose absolute offset is smaller than the
// requested offset. The malicious reply is crafted to trigger the underflow in
// Conn.Read's offset normalization logic, which in turn causes a slice bounds
// panic (the current buggy behaviour).
func TestReadStructuredReplyOffsetUnderflow(t *testing.T) {
	clientConn, serverConn := net.Pipe()
	defer clientConn.Close()
	defer serverConn.Close()

	conn := &Conn{
		conn:       clientConn,
		buflk:      make(chan struct{}, 1),
		buf:        make([]byte, DefaultBufferSize),
		structured: true,
	}
	conn.buflk <- struct{}{}
	conn.state_.Store(int32(connectionStateTransmission))
	conn.inTransmission.Store(true)

	errCh := make(chan error, 1)
	go func() {
		defer close(errCh)
		defer serverConn.Close()

		var req nbdproto.RequestHeader
		if err := binary.Read(serverConn, binary.BigEndian, &req); err != nil {
			errCh <- fmt.Errorf("server: read request header: %w", err)
			return
		}

		payload := []byte{0xaa, 0xbb, 0xcc, 0xdd}
		hdr := nbdproto.StructuredReplyHeader{
			Magic:  nbdproto.NBD_STRUCTURED_REPLY_MAGIC,
			Flags:  nbdproto.REPLY_FLAG_DONE,
			Type:   nbdproto.REPLY_TYPE_OFFSET_DATA,
			Cookie: req.Cookie,
			Length: uint32(8 + len(payload)),
		}

		if err := binary.Write(serverConn, binary.BigEndian, hdr); err != nil {
			errCh <- fmt.Errorf("server: write structured header: %w", err)
			return
		}

		absoluteOffset := req.Offset - 1
		if err := binary.Write(serverConn, binary.BigEndian, absoluteOffset); err != nil {
			errCh <- fmt.Errorf("server: write absolute offset: %w", err)
			return
		}

		if _, err := serverConn.Write(payload); err != nil {
			errCh <- fmt.Errorf("server: write payload: %w", err)
			return
		}

		errCh <- nil
	}()

	buf := make([]byte, 512)

	defer func() {
		if err := <-errCh; err != nil {
			t.Fatalf("server goroutine error: %v", err)
		}
		if r := recover(); r == nil {
			t.Fatalf("expected Conn.Read to panic on offset underflow, but it returned normally")
		}
	}()

	if _, err := conn.Read(buf, 0, 0); err != nil {
		t.Fatalf("Conn.Read returned error before panic: %v", err)
	}
}
